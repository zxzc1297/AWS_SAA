# 문제 풀이 노트 (9-12편)

[↩️ 메인으로 돌아가기](../README.md)

---

## ## 문제 9: 보안 - 안전한 3-tier 아키텍처의 정석

> **시나리오:**
> 한 기업이 AWS에 전통적인 3-tier 웹 애플리케이션을 배포하려고 합니다. 이 아키텍처는 웹 계층(Web Tier), 애플리케이션 계층(App Tier), 데이터베이스 계층(DB Tier)으로 구성됩니다. 보안팀은 다음과 같은 엄격한 요구사항을 제시했습니다.
>
> **요구사항:**
> 1.  웹 서버는 인터넷에서 HTTPS(포트 443) 트래픽을 수신할 수 있어야 합니다.
> 2.  애플리케이션 서버는 오직 웹 서버로부터의 트래픽만 수신해야 하며, 인터넷에서 직접 접근할 수 없어야 합니다.
> 3.  하지만, 애플리케이션 서버는 외부 레포지토리에서 소프트웨어 업데이트나 보안 패치를 다운로드하기 위해 인터넷으로 **나가는(Outbound)** 연결이 가능해야 합니다.
> 4.  데이터베이스 서버는 오직 애플리케이션 서버로부터의 트래픽만 수신해야 합니다.
>
> **문제:** 이 모든 보안 요구사항을 가장 잘 충족하는 네트워크 설계는 무엇입니까?
>
> **A.** 모든 계층(웹, 앱, DB)의 인스턴스를 단일 퍼블릭 서브넷에 배치합니다. 각 계층별로 보안 그룹을 할당하고, 이전 계층의 보안 그룹 ID를 소스로 지정하여 트래픽을 제어합니다.
>
> **B.** 웹 계층을 위한 퍼블릭 서브넷과, 애플리케이션 및 데이터베이스 계층을 위한 프라이빗 서브넷을 생성합니다. 애플리케이션 서버가 업데이트를 할 수 있도록 각 애플리케이션 서버에 탄력적 IP(Elastic IP) 주소를 할당합니다.
>
> **C.** 웹 계층을 위한 퍼블릭 서브넷과 애플리케이션 계층을 위한 프라이빗 서브넷을 생성합니다. 퍼블릭 서브넷에 **NAT 게이트웨이(NAT Gateway)**를 배치하고, 프라이빗 서브넷의 라우팅 테이블을 수정하여 인터넷 바운드 트래픽(0.0.0.0/0)이 NAT 게이트웨이를 향하도록 설정합니다.
>
> **D.** 웹 계층을 위한 퍼블릭 서브넷과 애플리케이션 계층을 위한 프라이빗 서브넷을 생성합니다. 프라이빗 서브넷의 **네트워크 ACL(NACL)**에서 인터넷으로 나가는 트래픽과 해당 응답 트래픽을 명시적으로 허용하도록 규칙을 설정합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 이 시나리오의 정석적인 해결책은 웹 서버는 **퍼블릭 서브넷**에, 애플리케이션 서버는 **프라이빗 서브넷**에 두어 역할을 분리하는 것입니다. 핵심은 프라이빗 서브넷의 인터넷 연결 문제인데, 여기서 **`NAT 게이트웨이`**가 사용됩니다. NAT 게이트웨이를 퍼블릭 서브넷에 배치하고 프라이빗 서브넷의 트래픽이 이 게이트웨이를 통해 인터넷으로 나가도록 설정하면, 내부 서버가 외부로 연결(Outbound)하는 것은 가능하지만, 외부에서 내부 서버로 직접 연결(Inbound)하는 것은 막을 수 있어 보안 요구사항을 완벽하게 충족할 수 있습니다.

* **핵심 개념:** 보안 그룹과 네트워크 ACL(NACL) 비교

| 구분 | **보안 그룹 (Security Group)** | **네트워크 ACL (NACL)** |
| :--- | :--- | :--- |
| **적용 수준** | **인스턴스 (ENI)** | **서브넷** |
| **상태** | **Stateful** (상태 저장) | **Stateless** (상태 비저장) |
| **규칙** | **허용(Allow) 규칙만** 가능 | **허용(Allow) 및 거부(Deny) 규칙** 모두 가능 |
| **동작 방식** | 아웃바운드 요청에 대한 응답 트래픽은 자동으로 허용 | 인바운드와 아웃바운드 규칙을 각각 별도로 설정해야 함 |

---

## ## 문제 10: 고성능 - HPC 워크로드를 위한 파일 시스템 선택

> **시나리오:**
> 한 생명과학 연구소에서 대규모 유전자 시퀀싱 분석을 위해 수백 개의 Linux EC2 인스턴스로 구성된 클러스터를 사용합니다. 이 분석 작업은 모든 인스턴스가 동시에 접근할 수 있는 공유 파일 시스템을 필요로 합니다.
>
> **요구사항:**
> 1.  모든 인스턴스에서 POSIX 호환 파일 시스템으로 접근할 수 있어야 합니다.
> 2.  분석이 진행되는 동안, 수백 GB/s에 달하는 대규모 병렬 처리량과 1밀리초 미만의 매우 짧은 지연 시간(latency)이 필요합니다.
> 3.  분석에 사용할 원본 데이터는 S3 버킷에 저장되어 있으며, 분석이 끝나면 결과물도 다시 동일한 S3 버킷에 저장되어야 합니다.
>
> **문제:** 이러한 고성능 컴퓨팅(HPC) 워크로드에 가장 높은 성능을 제공하는 스토리지 솔루션은 무엇입니까?
>
> **A.** `최대 I/O(Max I/O)` 성능 모드로 Amazon EFS 파일 시스템을 생성하고, 모든 EC2 인스턴스에 마운트합니다.
>
> **B.** `프로비저닝된 IOPS SSD(io2)` EBS 볼륨 여러 개를 RAID 0으로 구성한 대용량 EC2 인스턴스를 생성하고, 이를 NFS 서버로 설정하여 클러스터에 공유합니다.
>
> **C.** S3 데이터 리포지토리에 연결된 **Amazon FSx for Lustre** 파일 시스템을 생성하고, 모든 EC2 인스턴스에 마운트합니다.
>
> **D.** 각 EC2 인스턴스에서 S3 API를 직접 사용하여 S3 버킷의 데이터를 읽고 쓰도록 애플리케이션을 수정합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 문제에서 `HPC`, `수백 GB/s 처리량`, `1밀리초 미만 지연 시간` 같은 극단적인 성능 요구사항을 보고 **`Amazon FSx for Lustre`**가 정답임을 알 수 있습니다. `Amazon EFS`가 범용적인 파일 공유 환경에 적합하다면, `FSx for Lustre`는 HPC나 머신러닝처럼 최고의 성능이 필요한 워크로드를 위해 태어난 특화 서비스입니다. 특히 S3 버킷과 직접 연결하여 데이터를 고속으로 처리하고 다시 S3에 저장하는 기능은 이 시나리오에 최적화되어 있습니다.

* **핵심 개념:** AWS 파일 시스템 서비스 구분하기

| 요구사항 | **최적 서비스** |
| :--- | :--- |
| **Windows** 애플리케이션, **SMB** 프로토콜 필요 | **Amazon FSx for Windows File Server** |
| **Linux** 애플리케이션, **NFS** 프로토콜 필요 | **Amazon EFS** |
| **고성능 컴퓨팅(HPC)**, 대규모 병렬 처리 | **Amazon FSx for Lustre** |

---

## ## 문제 11: 비용 최적화 - 컨테이너, 똑똑하고 저렴하게 운영하기

> **시나리오:**
> 한 스타트업이 Amazon ECS에서 컨테이너화된 마이크로서비스 애플리케이션을 운영하고 있습니다. 이 애플리케이션은 평소에는 트래픽이 적지만, 마케팅 캠페인 중에는 갑작스럽고 예측 불가능한 트래픽 급증을 경험합니다. 현재 아키텍처는 잠재적 피크에 대비하기 위해 EC2 온디맨드 인스턴스를 과도하게 프로비저닝하여 평상시에 높은 비용이 발생하고 있습니다.
>
> **요구사항:**
> 컴퓨팅 비용과 운영 오버헤드를 크게 줄이면서 애플리케이션이 신속하게 확장될 수 있도록 해야 합니다. 개별 애플리케이션 작업은 내결함성이 있도록 설계되었습니다.
>
> **문제:** 가장 비용 효율적이고 운영이 효율적인 솔루션은 무엇입니까?
>
> **A.** ECS 클러스터를 온디맨드 인스턴스 대신 EC2 스팟 인스턴스에서 실행하도록 마이그레이션합니다.
>
> **B.** 관찰된 평균 EC2 사용량에 맞춰 컴퓨팅 절약 계획을 구매합니다.
>
> **C.** ECS 서비스를 **AWS Fargate** 시작 유형을 사용하도록 재구성합니다. 기준선을 위해 소수의 Fargate 온디맨드 작업과 함께, 주로 **Fargate Spot**을 작업에 사용하는 용량 공급자 전략을 사용합니다.
>
> **D.** 애플리케이션을 Application Load Balancer가 지원하는 AWS Lambda 함수에서 실행되도록 재설계합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 이 문제는 '비용'과 '운영' 두 가지를 모두 잡는 것이 핵심이었습니다. **`AWS Fargate`**는 EC2 인스턴스 관리가 전혀 필요 없는 **서버리스 컨테이너 엔진**이라, 운영 부담을 완벽하게 해결해 줍니다. 비용 문제는 **`Fargate Spot`**으로 해결합니다. 내결함성이 있는 작업이라면, 최대 70%까지 저렴한 스팟 용량을 활용해 비용을 크게 절감할 수 있습니다. 즉, **Fargate로 서버 관리를 없애고, Fargate Spot으로 비용을 최적화**하는 것이 이 시나리오의 가장 현대적이고 효율적인 접근 방식입니다.

* **핵심 개념:** ECS 시작 유형 비교

| 구분 | **EC2 시작 유형** | **AWS Fargate 시작 유형** |
| :--- | :--- | :--- |
| **인프라 관리** | **사용자 책임** (EC2 인스턴스 선택, 패치, 스케일링) | **AWS 책임** (서버리스) |
| **제어 수준** | 높음 (OS, 네트워킹 등 세부 제어 가능) | 낮음 (컨테이너 수준에 집중) |
| **비용 모델** | EC2 인스턴스 요금 (RI/Spot 적용 용이) | vCPU 및 메모리 사용량 기반 요금 (Fargate Spot 가능) |
| **적합한 경우** | OS 수준 제어가 필요하거나, 예측 가능한 장기 워크로드 | 운영 부담 최소화, 예측 불가능한/단기 워크로드 |

---

## ## 문제 12: 탄력성 - 마이크로서비스, '팬아웃'으로 소통하기

> **시나리오:**
> 한 이커머스 플랫폼의 `주문 서비스`는 새로운 주문이 생성될 때마다 `재고 서비스`, `배송 서비스`, `분석 서비스`에 이를 알려야 합니다. 현재 `주문 서비스`는 각 서비스의 API를 직접 호출하고 있는데, `분석 서비스`가 느려지거나 장애가 발생하면 전체 주문 프로세스가 지연되거나 실패하는 문제가 발생하고 있습니다.
>
> **요구사항:**
> 1. `주문 서비스`를 다른 하위 서비스들로부터 완전히 분리(decouple)해야 합니다.
> 2. 하나의 하위 서비스 장애가 다른 서비스나 전체 주문 프로세스에 영향을 주지 않아야 합니다.
> 3. 모든 하위 서비스는 주문 알림을 반드시 수신해야 합니다.
> 4. 향후 새로운 서비스가 추가되더라도 `주문 서비스`의 코드를 변경하지 않고 유연하게 확장할 수 있어야 합니다.
>
> **문제:** 이 모든 요구사항을 충족하는 가장 탄력적이고 확장 가능한 아키텍처는 무엇입니까?
>
> **A.** `주문 서비스`가 단일 Amazon SQS 표준 대기열에 주문 메시지를 보내고, 모든 하위 서비스(재고, 배송, 분석)가 이 대기열을 함께 폴링하여 메시지를 가져가도록 구성합니다.
>
> **B.** 각 하위 서비스를 위한 별도의 SQS 대기열을 생성합니다. `주문 서비스`는 `재고 서비스 큐`, `배송 서비스 큐`, `분석 서비스 큐` 각각에 동일한 주문 메시지를 보내도록 로직을 수정합니다.
>
> **C.** `주문 서비스`가 Amazon Kinesis Data Streams에 주문 레코드를 전송한다. 각 하위 서비스는 Kinesis 스트림의 컨슈머가 되어 데이터를 읽어간다.
>
> **D.** **Amazon SNS 주제(Topic)**를 생성하고 `주문 서비스`가 이 주제에 메시지를 발행(publish)하도록 한다. 각 하위 서비스를 위한 별도의 **Amazon SQS 대기열**을 생성하고, 이 대기열들을 모두 SNS 주제에 **구독(subscribe)**시킨다.

---

### ### 풀이 및 정리

✅ **정답: D**

* **정답 분석:** '하나의 이벤트가 발생했을 때, 여러 독립적인 작업이 병렬로 처리되어야 한다'는 요구사항을 보고 **`SNS + SQS`를 조합한 팬아웃(Fan-out) 패턴**을 바로 떠올렸습니다. `주문 서비스`는 그저 `SNS` 주제(Topic)라는 '방송국'에 한번 메시지를 보내면, 이 방송을 '구독'하고 있는 각 서비스의 전용 `SQS` 대기열(개인 우편함)로 메시지가 한 부씩 복사되어 배달됩니다. 각 서비스는 자신의 우편함만 확인하면 되므로, 다른 서비스의 장애에 전혀 영향을 받지 않고, 새로운 구독자를 추가하기도 매우 쉽습니다.

* **핵심 개념:** SNS와 SQS의 역할 비교

| 구분 | **Amazon SNS (Simple Notification Service)** | **Amazon SQS (Simple Queue Service)** |
| :--- | :--- | :--- |
| **패턴** | **발행/구독 (Pub/Sub)** | **대기열 (Queue)** |
| **메시지 전달** | **1:N (하나의 메시지를 여러 구독자에게 방송)** | **1:1 (하나의 메시지를 하나의 소비자가 처리)** |
| **주요 용도** | 알림, 이벤트 트리거, **팬아웃(Fan-out)** | 비동기 작업 처리, 작업 부하 분산, **디커플링** |
| **데이터 보관** | 메시지를 즉시 구독자에게 푸시 (영구 보관 안 함) | 소비자가 처리할 때까지 메시지를 안전하게 보관 |
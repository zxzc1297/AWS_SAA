# 문제 풀이 노트 (17-20편)

[↩️ 메인으로 돌아가기](../README.md)

---

## ## 문제 17: 비용 최적화 - '유휴 상태' 데이터베이스 비용 없애기

> **시나리오:**
> 한 개발팀이 신규 애플리케이션의 개발 및 테스트 환경을 위해 Amazon RDS for MySQL 데이터베이스를 사용하고 있습니다. 이 데이터베이스의 사용량은 매우 간헐적이고 예측이 불가능합니다. 개발자들이 통합 테스트를 실행하는 몇 시간 동안은 집중적으로 사용되지만, 그 외 대부분의 시간, 특히 밤과 주말에는 완전히 유휴 상태(idle)로 남아있습니다.
>
> **요구사항:**
> 1.  개발 환경의 데이터베이스 비용을 대폭 절감해야 합니다.
> 2.  개발자가 테스트를 시작하면, 데이터베이스는 즉시 사용 가능해야 합니다.
> 3.  데이터베이스를 수동으로 켜고 끄는 작업을 최소화하고 싶습니다.
>
> **문제:** 다음 중 이러한 요구사항을 가장 비용 효율적으로 충족하는 솔루션은 무엇입니까?
>
> **A.** 현재 RDS 인스턴스에 대해 1년 약정의 예약 인스턴스(Reserved Instance)를 구매하여 시간당 요금을 할인받습니다.
>
> **B.** 매일 밤 데이터베이스를 중지하고 아침에 다시 시작하도록 AWS Lambda 함수와 Amazon EventBridge 스케줄을 사용하여 자동화 스크립트를 구현합니다.
>
> **C.** 현재 RDS 인스턴스의 크기를 가장 작은 인스턴스 유형(예: db.t3.micro)으로 변경하여 기본 비용을 낮추고, 필요시 수동으로 확장합니다.
>
> **D.** 데이터베이스를 **Amazon Aurora Serverless v2**로 마이그레이션하고, 최소 및 최대 용량 단위를 설정하여 사용량에 따라 자동으로 용량이 조절되도록 구성합니다.

---

### ### 풀이 및 정리

✅ **정답: D**

* **정답 분석:** 이 문제의 핵심은 **'예측 불가능하고 간헐적인'** 워크로드였습니다. `예약 인스턴스`는 꾸준한 사용량에, `자동 중지/시작 스크립트`는 예측 가능한 스케줄에 적합하므로 둘 다 정답이 아니었죠. 이럴 때를 위해 만들어진 서비스가 바로 **`Amazon Aurora Serverless`**였습니다. 이 서비스는 사용량이 없을 때 컴퓨팅 용량을 거의 0에 가깝게 자동으로 축소하여 비용을 최소화하고, 요청이 들어오면 즉시 확장하여 응답합니다. '사용한 만큼만 지불한다'는 클라우드의 이상을 데이터베이스에서 실현한 완벽한 솔루션이었습니다.

* **핵심 개념:** 데이터베이스 워크로드 유형별 최적 솔루션 비교

| 워크로드 유형 | **프로비저닝 RDS/Aurora (+ RI)** | **Amazon Aurora Serverless** |
| :--- | :--- | :--- |
| **적합한 경우** | 꾸준하고 예측 가능한 사용량 (예: 프로덕션 웹 서버) | **간헐적이고 예측 불가능한 사용량** (예: 개발/테스트, 내부 어드민 툴) |
| **비용 모델** | 시간당 요금 (약정 시 할인) | **사용한 만큼만 지불** (ACU-hour) |
| **스케일링** | 수동 또는 예약 기반 | **자동 (요청 기반)** |

---

## ## 문제 18: 탄력성 - 서버는 사라져도 '세션'은 남는다

> **시나리오:**
> 한 웹 애플리케이션은 사용자가 업로드한 이미지를 편집하는 기능을 제공하며, `Auto Scaling` 그룹의 `EC2` 인스턴스에서 실행됩니다. 이미지 편집 중 발생하는 사용자 세션 데이터와 중간 작업 상태는 현재 각 `EC2` 인스턴스의 로컬 디스크에 저장됩니다. 이 방식의 문제점은 `Auto Scaling` 그룹이 축소(Scale-in)되거나 특정 인스턴스가 상태 검사에 실패하여 종료될 경우, 해당 인스턴스에서 진행 중이던 모든 사용자 세션과 작업 내용이 유실된다는 것입니다.
>
> **요구사항:**
> 1.  사용자의 세션 상태를 `EC2` 인스턴스 외부의 공유 스토어에 저장해야 합니다.
> 2.  사용자가 어떤 `EC2` 인스턴스에 연결되더라도 세션이 유지되고 작업을 이어갈 수 있어야 합니다.
> 3.  세션 데이터에 대한 읽기/쓰기 작업은 응답 지연이 거의 없어야 합니다(low latency).
> 4.  솔루션은 고가용성을 갖추어야 합니다.
>
> **문제:** 다음 중 이러한 요구사항을 충족하는 가장 탄력적이고 성능이 뛰어난 솔루션은 무엇입니까?
>
> **A.** 모든 세션 데이터를 **Amazon EFS** 파일 시스템에 저장하고, `Auto Scaling` 그룹의 모든 `EC2` 인스턴스에 이 파일 시스템을 마운트하여 공유합니다.
>
> **B.** **Amazon ElastiCache for Redis** 클러스터를 배포합니다. 애플리케이션이 모든 세션 데이터를 로컬 디스크 대신 `ElastiCache` 클러스터에 저장하고 읽어오도록 수정합니다.
>
> **C.** 모든 세션 데이터를 **Amazon S3** 버킷에 파일 형태로 저장합니다. 애플리케이션은 필요할 때마다 `S3`에서 세션 파일을 읽고 쓰도록 수정합니다.
>
> **D.** `Application Load Balancer`의 **고정 세션(Sticky sessions)** 기능을 활성화하여 사용자가 항상 동일한 `EC2` 인스턴스로만 라우팅되도록 설정합니다.

---

### ### 풀이 및 정리

✅ **정답: B**

* **정답 분석:** 이 문제를 해결하기 위한 핵심 원칙은 **'컴퓨팅 인스턴스를 상태 비저장(Stateless)으로 만드는 것'**이었습니다. 즉, 중요한 상태(State) 정보를 인스턴스 외부의 중앙 저장소로 분리하는 것이죠. 세션 데이터처럼 빠르고 빈번한 읽기/쓰기가 필요한 경우에는 **인메모리 데이터 스토어인 `Amazon ElastiCache`**가 가장 적합한 선택지였습니다. '고정 세션' 기능은 특정 인스턴스가 사라지면 세션도 함께 사라지므로 근본적인 해결책이 될 수 없다는 점을 구분하는 것이 중요했습니다.

* **핵심 개념:** 세션 데이터 저장소 비교

| 스토리지 유형 | **Amazon ElastiCache (Redis)** | **Amazon EFS** | **Amazon S3** | **EC2 로컬 디스크 + 고정 세션** |
| :--- | :--- | :--- | :--- | :--- |
| **주 용도** | **인메모리 캐시, 세션 스토어** | 공유 파일 시스템 (NFS) | 객체 스토리지 | - |
| **지연 시간** | **매우 낮음 (마이크로초)** | 낮음 (밀리초) | 높음 | 매우 낮음 |
| **탄력성** | **HA 구성 가능 (외부 저장)** | **HA 구성 가능 (외부 저장)** | **HA 구성 가능 (외부 저장)** | **인스턴스 장애 시 유실** |

---

## ## 문제 19: 보안 - S3 데이터를 위한 '절대 방어' 설정하기

> **시나리오:**
> 한 금융 회사는 규제 준수를 위해 거래 기록, 계약서 등 민감하고 중요한 문서를 Amazon S3 버킷에 아카이빙하고 있습니다. 이 데이터는 법적 요구사항에 따라 한번 저장되면 절대 위변조되거나 삭제되어서는 안 됩니다.
>
> **요구사항:**
> 1.  **불변성(Immutability):** 파일이 S3에 한번 저장되면, 지정된 보존 기간(예: 5년) 동안 계정의 루트 사용자를 포함한 그 누구도 파일을 덮어쓰거나 삭제할 수 없어야 합니다(WORM - Write-Once, Read-Many 모델).
> 2.  **실수 방지:** 권한을 가진 관리자라도 실수로 객체를 영구 삭제하거나 버킷의 보호 설정을 쉽게 비활성화할 수 없도록 추가적인 안전장치가 필요합니다.
>
> **문제:** 다음 중 이러한 엄격한 데이터 보존 및 보호 요구사항을 가장 강력하게 충족하는 솔루션은 무엇입니까?
>
> **A.** S3 버킷에 **버전 관리(Versioning)**를 활성화하고, 실수로 삭제된 객체는 이전 버전을 복원하여 대응합니다.
>
> **B.** 모든 사용자에 대해 `s3:DeleteObject` 작업을 거부(Deny)하는 S3 버킷 정책을 적용하고, 이 정책이 수정되지 않도록 관리자에게만 제한적인 권한을 부여합니다.
>
> **C.** S3 버킷에 **객체 잠금(Object Lock)**을 `규정 준수(Compliance)` 모드로 활성화하고, **버전 관리(Versioning)**와 **MFA Delete**를 함께 활성화합니다.
>
> **D.** 모든 객체를 **SSE-KMS**로 암호화하고, 키 정책에서 데이터 삭제 권한을 가진 역할을 제외한 모든 주체(Principal)의 암호화 및 복호화 권한을 거부합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 이 시나리오의 해답은 세 가지 기능을 조합하는 것이었습니다. **`객체 잠금(Object Lock)` in `규정 준수(Compliance)` 모드**는 보존 기간 동안 루트 계정조차 객체 버전을 삭제하거나 설정을 변경하는 것을 불가능하게 만들어 데이터 불변성을 보장합니다. **`버전 관리`**는 기본 보호막 역할을 하며, **`MFA Delete`**는 버전 관리 설정을 변경하거나 객체 버전을 '영구적으로' 삭제하는 행위에 대해 MFA 추가 인증을 요구하여 최종 안전장치 역할을 합니다.

* **핵심 개념:** S3의 다계층 데이터 보호 기능

| 기능 | **버전 관리 (Versioning)** | **객체 잠금 (Object Lock)** | **MFA Delete** |
| :--- | :--- | :--- | :--- |
| **주요 목적** | 실수로 인한 덮어쓰기/삭제 방지 | **데이터 불변성 (WORM)** | 관리자 실수/권한 탈취 방지 |
| **보호 수준** | 삭제 마커 생성, 이전 버전 복구 가능 | 지정된 기간 동안 **그 누구도** 버전 삭제 불가 | 버전 상태 변경/영구 삭제 시 **MFA 인증 요구** |
| **강제성** | 낮음 (권한 있으면 영구 삭제 가능) | **매우 높음 (규정 준수 모드)** | **매우 높음** |

---

## ## 문제 20: 탄력성 - 시스템이 스스로를 치료하게 만들기

> **시나리오:**
> 한 회사의 웹 애플리케이션은 Application Load Balancer(ALB) 뒤에서 EC2 Auto Scaling 그룹에 의해 관리되고 있습니다. 때때로 EC2 인스턴스 자체는 정상적으로 작동하는 것처럼 보이지만(예: CPU, 네트워크 정상), 인스턴스 내부의 애플리케이션 프로세스가 응답이 없거나 멈추는 현상이 발생합니다. 현재 Auto Scaling 그룹은 기본 EC2 상태 검사만 사용하고 있어, 이러한 애플리케이션 수준의 장애를 감지하지 못합니다.
>
> **요구사항:**
> * 애플리케이션 수준의 장애를 자동으로 감지해야 합니다.
> * 장애가 감지된 인스턴스는 자동으로 서비스에서 제외되고, 새로운 정상 인스턴스로 교체되어야 합니다 (자동 복구).
> * 솔루션은 AWS의 네이티브 기능을 최대한 활용하여 관리 부담이 적어야 합니다.
>
> **문제:** 다음 중 이러한 요구사항을 충족하는 가장 효과적이고 일반적인 방법은 무엇입니까?
>
> **A.** **Amazon Route 53**의 상태 검사를 사용하여 각 EC2 인스턴스의 애플리케이션 포트를 모니터링하고, 장애 발생 시 DNS 응답에서 해당 인스턴스를 제외합니다.
>
> **B.** **Amazon CloudWatch** 경보를 설정하여 애플리케이션 응답률과 같은 지표를 모니터링합니다. 지표가 임계값 아래로 떨어지면, SNS 주제로 알림을 보내 운영자가 수동으로 조치하도록 합니다.
>
> **C.** 각 EC2 인스턴스에 애플리케이션의 내부 상태를 확인하는 사용자 지정 스크립트를 배포합니다. 장애가 감지되면 스크립트가 AWS CLI의 `SetInstanceHealth` 명령을 실행하여 해당 인스턴스를 '비정상' 상태로 직접 설정합니다.
>
> **D.** **Application Load Balancer(ALB)의 상태 검사**가 애플리케이션의 상태 확인 페이지(예: `/health`)를 주기적으로 확인하도록 설정합니다. 그리고 **Auto Scaling 그룹의 상태 검사 유형을 `ELB`로 지정**하여 ALB의 상태 검사 결과를 상속받도록 구성합니다.

---

### ### 풀이 및 정리

✅ **정답: D**

* **정답 분석:** 이 문제를 해결하는 열쇠는 **`Auto Scaling 그룹`과 `Application Load Balancer(ALB)`의 상태 검사를 연동**하는 것이었습니다. ALB의 상태 검사가 애플리케이션의 `/health` 같은 경로를 호출하여 앱의 실제 건강 상태를 확인하게 하고, Auto Scaling 그룹의 상태 검사 유형을 `ELB`로 변경하면, ALB가 "앱이 응답 없음!"이라고 판단했을 때 Auto Scaling 그룹이 그 판단을 이어받아 해당 인스턴스를 **자동으로 종료하고 건강한 새 인스턴스로 교체**하는 완벽한 자동 복구(Self-healing) 루프가 완성됩니다.

* **핵심 개념:** Auto Scaling 그룹의 상태 검사 유형

| 상태 검사 유형 | **EC2 상태 검사 (기본값)** | **ELB 상태 검사** |
| :--- | :--- | :--- |
| **검사 대상** | **인프라** (VM, 하드웨어, 네트워크) | **애플리케이션** (`/health` 엔드포인트 응답 등) |
| **장애 감지** | 인스턴스 중지/응답 없음 | 애플리케이션 프로세스 멈춤/오류 응답 |
| **ASG 동작** | 인프라 장애 시 인스턴스 교체 | **애플리케이션 장애 시 인스턴스 교체** |
| **권장 사용 사례** | 일반적인 경우 | **로드 밸런서 뒤에서 실행되는 애플리케이션** |
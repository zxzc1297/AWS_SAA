# 문제 풀이 노트 (61-64편)

[↩️ 메인으로 돌아가기](../README.md)

---

## 문제 61: S3 데이터의 우발적인 삭제 및 덮어쓰기로부터 복구

> **시나리오:**
> 한 회사는 사용자가 업로드한 중요 문서를 Amazon S3 버킷에 저장하는 문서 관리 시스템을 운영하고 있습니다. 최근 애플리케이션 버그나 개발자 실수로 인해 중요 문서가 덮어쓰기 되거나 삭제되는 사고가 발생했습니다.
>
> **요구사항:**
> 1.  **덮어쓰기 보호:** 파일이 실수로 덮어쓰기 된 경우, 이전 버전을 복구할 수 있어야 합니다.
> 2.  **삭제 보호:** 파일이 실수로 삭제된 경우, 삭제된 파일을 복구할 수 있어야 합니다.
> 3.  **자동 정리:** 현재 사용되지 않는 이전 버전의 문서는 365일 후에 자동으로 영구 삭제되어야 합니다.
>
> **문제:**
> 이러한 요구사항을 모두 충족하는 가장 간단하고 효과적인 방법은 무엇입니까?
>
> A. S3 버킷에 **S3 버전 관리(Versioning)**를 활성화합니다. 365일이 지난 최신이 아닌 버전(Non-current versions)의 객체를 영구적으로 삭제하도록 **S3 수명 주기 정책(Lifecycle policy)**을 구성합니다.
> B. S3 교차 리전 복제(Cross-Region Replication)를 활성화하여 버킷을 다른 AWS 리전으로 복제합니다.
> C. **AWS Backup**을 사용하여 S3 버킷에 대한 일일 백업 작업을 생성합니다.
> D. S3 버킷에 365일 보존 기간으로 **S3 객체 잠금(Object Lock)**을 활성화합니다.

### 풀이 및 정리

✅ **정답: A**

- **솔루션 분석:** 해결책은 S3 객체의 우발적인 덮어쓰기 및 삭제로부터 복구하는 기능과 오래된 버전을 자동 정리하는 기능을 제공해야 합니다. **S3 버전 관리**는 객체의 모든 버전을 보존하여 덮어쓰기 및 삭제(삭제 마커 사용)로부터 데이터를 보호합니다. **S3 수명 주기 정책**은 최신이 아닌 버전을 대상으로 지정하여 특정 기간이 지나면 자동으로 영구 삭제함으로써 비용을 관리합니다. 이 조합이 가장 효율적인 네이티브 솔루션입니다.

- **핵심 개념: S3 버전 관리(Versioning) 동작 방식**
| 액션 (Action) | 버전 관리 비활성화 시 | 버전 관리 활성화 시 |
| :--- | :--- | :--- |
| **객체 덮어쓰기** | 데이터가 영구적으로 변경됨 | 새로운 버전이 생성되고, 이전 버전은 보존됨 |
| **객체 삭제** | 데이터가 영구적으로 삭제됨 | **'삭제 마커(Delete Marker)'**가 생성되고, 이전 버전은 보존됨 |


---

## 문제 62: AWS Elastic Beanstalk 배포 전략의 비용 및 가용성 최적화

> **시나리오:**
> AWS Elastic Beanstalk를 사용하는 프로덕션 환경에서 "한 번에 모두(All at once)" 정책으로 배포하여 다운타임이 발생하고 있습니다. 무중단 배포는 필수적이지만, 배포 때마다 인스턴스 용량을 두 배로 늘리는 방식의 비용 증가는 피하고 싶습니다.
>
> **요구사항:**
> 1.  **무중단 배포:** 서비스 중단 없이 배포가 이루어져야 합니다.
> 2.  **비용 효율성:** 배포 중 인프라 용량을 두 배로 늘리는 것을 피해야 합니다.
> 3.  **성능 영향 최소화:** 배포 과정에서 성능 저하를 최소화해야 합니다.
>
> **문제:**
> 이러한 요구사항 간의 최적의 균형을 제공하는 Elastic Beanstalk 배포 정책은 무엇입니까?
>
> A. "한 번에 모두(All at once)" 정책을 계속 사용하되, 심야 유지보수 시간대에 배포를 예약합니다.
> B. "블루/그린(Blue/Green)" 배포 정책으로 전환합니다.
> C. "롤링(Rolling)" 배포 정책으로 전환합니다.
> D. "변경 불가능(Immutable)" 배포 정책으로 전환합니다.

### 풀이 및 정리

✅ **정답: C**

- **솔루션 분석:** **롤링(Rolling) 배포** 정책은 추가 EC2 인스턴스를 프로비저닝하지 않고 기존 인스턴스를 배치 단위로 순차 업데이트합니다. 이를 통해 추가 비용 없이 무중단 배포가 가능합니다. 배포 중 전체 용량이 일시적으로 감소하는 단점은 있지만, 다운타임을 피하면서 비용 증가도 없어야 하는 요구사항의 최적 절충안입니다. 'Immutable' 및 'Blue/Green' 정책은 무중단을 보장하지만 배포 중 일시적으로 리소스를 두 배로 사용하므로 비용 효율성 요구사항을 위반합니다.

- **핵심 개념: Elastic Beanstalk 배포 정책 비교**
| 배포 정책 (Policy) | **가용성 (Downtime)** | **배포 중 추가 비용** | **배포 중 용량** |
| :--- | :--- | :--- | :--- |
| **All at once** | **있음 (짧음)** | 없음 | 0%로 감소 |
| **Rolling** | 없음 | **없음** | **일시적 감소** |
| **Immutable** | 없음 | **인스턴스 2배** | 100% 이상 유지 |
| **Blue/Green** | 없음 | **전체 환경 2배** | 100% 이상 유지 |


---

## 문제 63: EC2 인스턴스의 하드웨어 장애 자동 복구

> **시나리오:**
> 상태 저장(stateful) 애플리케이션을 단일 EC2 인스턴스에서 운영하고 있습니다. EC2 인스턴스가 실행 중인 물리적 호스트 하드웨어에 장애가 발생하면 인스턴스가 응답 불능 상태가 되며, 현재는 수동으로 복구하고 있어 복구 시간(RTO)이 매우 깁니다.
>
> **요구사항:**
> 1.  **자동 복구:** 하드웨어 장애를 자동으로 감지하고 복구해야 합니다.
> 2.  **상태 보존:** 복구 시 인스턴스 ID, 탄력적 IP, 연결된 EBS 볼륨 등은 그대로 보존되어야 합니다.
> 3.  **수동 개입 없음:** 복구는 완전 자동화되어야 합니다.
>
> **문제:**
> 이러한 요구사항을 모두 충족하는 가장 간단하고 효과적인 솔루션은 무엇입니까?
>
> A. EC2 인스턴스를 최소/최대 크기가 1인 Auto Scaling 그룹에 배치합니다.
> B. 해당 EC2 인스턴스의 **`StatusCheckFailed_System`** 지표를 모니터링하는 **Amazon CloudWatch 경보**를 생성하고, 경보 발생 시 **인스턴스 복구(recover)** EC2 작업을 트리거하도록 구성합니다.
> C. CloudWatch 경보와 SNS, Lambda를 조합하여 인스턴스를 중지/시작하는 스크립트를 직접 구현합니다.
> D. 애플리케이션을 상태 비저장(stateless)으로 재설계하고 여러 가용 영역에 분산 배포합니다.

### 풀이 및 정리

✅ **정답: B**

- **솔루션 분석:** 이 시나리오는 AWS의 물리적 호스트 장애에 대응하는 것이 핵심입니다. **CloudWatch 경보**의 **EC2 복구 작업**은 바로 이러한 목적을 위해 설계된 기능입니다. `StatusCheckFailed_System` 지표를 통해 AWS 측 하드웨어 문제를 감지하고, 복구 작업이 트리거되면 인스턴스 ID, IP 주소, EBS 볼륨 등 모든 상태를 보존한 채 새로운 정상 호스트에서 인스턴스를 자동으로 재시작합니다. Auto Scaling 그룹은 인스턴스를 보존하는 대신 종료하고 새로 생성하므로 요구사항에 부합하지 않습니다.

- **핵심 개념: EC2 상태 확인(Status Checks)**
| 상태 확인 지표 | **`StatusCheckFailed_System`** | **`StatusCheckFailed_Instance`** |
| :--- | :--- | :--- |
| **원인** | **AWS 측 물리적 호스트 문제** (전원, 네트워크 등) | **인스턴스 내부 문제** (OS 부팅 실패, 잘못된 설정 등) |
| **자동 해결책** | **CloudWatch 경보 + '인스턴스 복구' 작업** | 사용자가 직접 재부팅 또는 OS 문제 해결 |
| **데이터 보존**| 복구 시 인스턴스 ID, IP, EBS 등 모두 보존 | 재부팅 시 메모리 데이터만 손실 |


---

## 문제 64: 확장 가능한 멀티 VPC 네트워크 아키텍처 설계

> **시나리오:**
> 한 대기업은 여러 부서별로 다수의 VPC를 운영하고 있으며, 이 VPC들은 서로, 그리고 온프레미스 데이터 센터와 통신해야 합니다. 또한 모든 인터넷 아웃바운드 트래픽은 보안 검사를 위해 단일 지점을 통과해야 합니다. VPC가 계속 추가될 예정이므로, 확장 가능하고 관리가 쉬운 네트워크 아키텍처가 필요합니다.
>
> **요구사항:**
> 1.  모든 VPC는 서로 통신할 수 있어야 합니다.
> 2.  인터넷 액세스는 중앙에서 제어되어야 합니다.
> 3.  모든 VPC는 온프레미스와 통신할 수 있어야 합니다.
> 4.  아키텍처는 확장 가능해야 하고 관리가 쉬워야 합니다.
>
> **문제:**
> 이러한 요구사항을 모두 충족하는 가장 확장성 있고 관리하기 쉬운 솔루션은 무엇입니까?
>
> A. 모든 VPC 간에 VPC 피어링(Peering) 연결을 맺어 풀 메시 네트워크를 구성합니다.
> B. **AWS Transit Gateway**를 중앙 허브로 배포합니다. 모든 VPC와 Direct Connect 게이트웨이를 여기에 연결하고, 별도의 "Egress VPC"를 통해 인터넷 트래픽을 중앙에서 제어합니다.
> C. **VPC 공유(Sharing)**를 사용하여 중앙 VPC의 서브넷을 다른 모든 계정과 공유합니다.
> D. 각 VPC의 서비스에 대해 **AWS PrivateLink**를 생성하여 VPC 간 통신을 구현합니다.

### 풀이 및 정리

✅ **정답: B**

- **솔루션 분석:** 다수의 VPC와 온프레미스 네트워크를 연결하는 확장 가능한 아키텍처에는 **AWS Transit Gateway**가 가장 적합합니다. Transit Gateway는 '허브 앤 스포크(Hub-and-Spoke)' 모델을 구현하는 클라우드 라우터 역할을 합니다. 각 VPC는 중앙의 Transit Gateway에 한 번만 연결하면 다른 모든 VPC 및 온프레미스와 통신할 수 있습니다. 이를 통해 VPC 피어링 메시의 복잡성을 해결하고, Egress VPC 패턴을 통해 아웃바운드 트래픽을 중앙에서 제어하는 등 확장성과 관리 용이성을 크게 향상시킬 수 있습니다.

- **핵심 개념: VPC Peering vs. AWS Transit Gateway**
| 구분 (Category)         | **VPC 피어링 (Peering)** | **AWS Transit Gateway** |
| :---------------------- | :----------------------------------------------------- | :------------------------------------------------------------- |
| **토폴로지 (Topology)** | 메시 (Mesh), 1:1 연결                                  | **허브 앤 스포크 (Hub-and-Spoke)** |
| **관리 복잡성** | VPC 수가 증가하면 매우 복잡해짐 (N\*(N-1)/2)             | **VPC 수에 상관없이 단순함** (N개 연결)                        |
| **전이적 라우팅** | **불가능** (A-B, B-C 연결 시 A-C 통신 불가)            | **가능** (중앙 허브 역할)                                      |
| **연결 대상** | VPC 간 연결만 가능                                     | VPC, VPN, Direct Connect Gateway                               |

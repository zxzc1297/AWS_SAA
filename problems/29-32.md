# 문제 풀이 노트 (29-32편)

[↩️ 메인으로 돌아가기](../README.md)

---

## ## 문제 29: 보안 - 자격 증명이 뚫려도 데이터를 지키는 법

> **시나리오:**
> 한 금융 회사는 매우 민감한 고객 재무 데이터를 Amazon S3 버킷에 저장하고 있습니다. 이 데이터는 특정 VPC (`vpc-12345`) 내의 프라이빗 서브넷에서 실행되는 EC2 인스턴스에서만 접근하여 처리해야 합니다.
>
> **요구사항:**
> 보안팀의 가장 중요한 요구사항은, 만약 EC2 인스턴스의 IAM 자격 증명(액세스 키 등)이 외부로 유출되더라도, 공격자가 지정된 VPC(`vpc-12345`) 외부의 다른 위치(예: 공격자의 노트북)에서는 S3 버킷의 데이터에 절대로 접근할 수 없도록 원천적으로 차단하는 것입니다.
>
> **문제:** 이러한 엄격한 보안 요구사항을 충족하는 가장 효과적인 방법은 무엇입니까?
>
> **A.** EC2 인스턴스의 보안 그룹(Security Group) 아웃바운드 규칙에 S3 서비스의 공식 IP 주소 범위를 추가하여, S3로만 통신하도록 제한합니다.
>
> **B.** S3 버킷의 모든 객체를 **AWS KMS 고객 관리형 키(CMK)**로 암호화합니다. KMS 키 정책에서 EC2 인스턴스의 IAM 역할에게만 `kms:Decrypt` 권한을 부여하여 데이터 접근을 통제합니다.
>
> **C.** **AWS Network Firewall**을 VPC의 엣지에 배포하고, `vpc-12345`의 CIDR 범위에서 시작되지 않은 모든 S3 API 요청을 차단하도록 규칙을 설정합니다.
>
> **D.** **S3 게이트웨이 VPC 엔드포인트**를 `vpc-12345`에 생성합니다. S3 버킷 정책에 `Condition`을 추가하여, `aws:sourceVpce`(소스 VPC 엔드포인트) 값이 해당 엔드포인트의 ID와 일치하지 않는 모든 요청을 명시적으로 거부(Deny)하도록 설정합니다.

---

### ### 풀이 및 정리

✅ **정답: D**

* **정답 분석:** 이 문제의 핵심은 '자격 증명(누가)' 기반 제어와 '네트워크 위치(어디서)' 기반 제어를 조합하는 것입니다. **S3 게이트웨이 VPC 엔드포인트**를 생성하면, 해당 VPC에서 나가는 S3 요청에는 고유한 엔드포인트 ID(`vpce-xxx`)가 태그처럼 붙습니다. 그리고 **S3 버킷 정책**에서 `Condition`을 사용해 "이 태그가 붙은 요청만 허용한다"고 규칙을 정하면, 설령 자격 증명이 유출되더라도 VPC 외부에서 오는 요청은 태그가 없으므로 원천적으로 차단됩니다.

* **핵심 개념:** IAM 정책과 리소스 정책의 역할

| 정책 유형 | **IAM 정책 (자격 증명 기반)** | **리소스 정책 (S3 버킷 정책 등)** |
| :--- | :--- | :--- |
| **제어 주체** | **"누가 (Who)"** - 이 사용자/역할은 무엇을 할 수 있는가? | **"무엇을 (What)"** - 이 리소스에 대해 누가 무엇을 할 수 있는가? |
| **주요 장점** | 중앙에서 사용자/역할에 권한 할당 | 리소스에 대한 접근 제어를 한 곳에서 명시 |
| **시너지** | 두 정책을 조합하여, **"누가, 어디서, 무엇을"** 할 수 있는지 강력하게 제어 가능 |

---

## ## 문제 30: 탄력성 - 스마트하게 재시도하는 방법

> **시나리오:**
> 한 마이크로서비스(`서비스 A`)는 외부 파트너사의 API(`서비스 B`)를 자주 호출해야 합니다. `서비스 B`는 때때로 일시적인 오류(HTTP 5xx)나 과부하로 인한 스로틀링 오류(HTTP 429)를 반환합니다. 현재 `서비스 A`는 API 호출 실패 시 즉시 재시도하도록 구현되어 있어, `서비스 B`의 장애를 오히려 악화시키고(`Thundering Herd` 문제), `서비스 A` 자체의 성능 저하까지 유발하고 있습니다.
>
> **문제:** 이러한 요구사항을 가장 잘 충족하는 클라이언트 측(client-side) 재시도 전략은 무엇입니까?
>
> **A.** API 호출 실패 횟수가 임계값을 초과하면, 일정 시간 동안 `서비스 B`로의 모든 호출을 즉시 실패 처리하여 `서비스 A`의 리소스를 보호하는 **서킷 브레이커(Circuit Breaker) 패턴**을 구현합니다.
>
> **B.** 실패한 API 호출 요청을 **Amazon SQS** 대기열에 보냅니다. 별도의 작업자 프로세스가 이 대기열을 폴링하여 API 호출을 재시도하고, 실패 시 메시지가 다시 대기열에 나타나도록 합니다.
>
> **C.** API 호출 실패 시, 재시도 간의 대기 시간을 점차적으로 늘리고(예: 1초, 2초, 4초, 8초) 약간의 임의성을 추가하여 여러 클라이언트가 동시에 재시도하는 것을 방지하는 **지수 백오프 및 지터(Exponential Backoff and Jitter)** 알고리즘을 구현합니다.
>
> **D.** 모든 API 호출을 **AWS Step Functions** 상태 머신으로 모델링하고, 내장된 `Retry` 기능을 사용하여 실패 시 최대 횟수까지 재시도하도록 구성합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 이 문제는 단순히 재시도를 하는 것을 넘어, 어떻게 '잘' 재시도할 것인가를 묻고 있었습니다. **`지수 백오프(Exponential Backoff)`**는 재시도 간격을 점차 늘려 상대방 서버에 복구할 시간을 주고, **`지터(Jitter)`**는 재시도 시점에 임의성을 추가하여 여러 클라이언트가 동시에 몰리는 것을 방지합니다. 이 두 가지를 조합한 C가 가장 근본적인 '재시도 전략' 자체를 설명하는 답이었습니다.

* **핵심 개념:** 탄력성 패턴 비교

| 패턴 | **주요 목표** | **동작 방식** |
| :--- | :--- | :--- |
| **지수 백오프 & 지터** | **성공적인 재시도** | 실패 시 대기 시간을 늘려가며 재시도하여, 상대방이 복구할 시간을 줌 |
| **서킷 브레이커** | **빠른 실패 및 클라이언트 보호** | 반복적인 실패 감지 시, 일정 시간 동안 호출을 차단하여 내 리소스를 보호함 |
| **디커플링 (SQS)** | **장애 격리 및 비동기 처리** | 중간에 대기열을 두어, 서비스 간 직접적인 의존성을 제거하고 작업을 안정적으로 보관함 |

---

## ## 문제 31: 고성능 - 마이크로초(μs) 단위의 응답속도 따라잡기

> **시나리오:**
> 한 광고 기술 회사는 온라인 광고를 위한 실시간 입찰(Real-Time Bidding, RTB) 플랫폼을 운영하고 있습니다. 이 플랫폼은 광고 입찰 요청을 받을 때마다, 광고주 프로필과 캠페인 데이터를 즉시 조회하여 수 밀리초(milliseconds) 안에 입찰 결정을 내려야 합니다.
>
> **요구사항:**
> * 데이터 조회 작업은 피크 시간대에 초당 수백만 건의 읽기 요청을 처리할 수 있어야 합니다.
> * 응답 시간은 반드시 **마이크로초(microseconds) 수준**의 매우 짧은 지연 시간을 유지해야 합니다.
>
> **문제:** 이러한 극도로 낮은 지연 시간과 대규모 읽기 처리량 요구사항을 가장 잘 충족하는 데이터베이스 및 캐싱 아키텍처는 무엇입니까?
>
> **A.** **Amazon RDS** 데이터베이스에 여러 개의 **읽기 전용 복제본(Read Replica)**을 구성하여 읽기 요청을 분산시킵니다.
>
> **B.** **Amazon Redshift** 클러스터를 사용하여 데이터를 저장하고, 대규모 병렬 처리(MPP) 아키텍처를 활용하여 빠른 조회를 수행합니다.
>
> **C.** **Amazon DynamoDB** 테이블에 데이터를 저장하고, 그 앞에 **DynamoDB Accelerator (DAX)** 클러스터를 배치하여 인메모리 캐싱을 제공합니다.
>
> **D.** **Amazon S3**에 데이터를 JSON 파일 형태로 저장하고, **Amazon Athena**를 사용하여 데이터를 빠르게 쿼리합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 이 문제의 핵심 키워드는 **'마이크로초(microseconds) 수준'**의 지연 시간이었습니다. `DynamoDB`가 자체적으로 한 자릿수 밀리초의 빠른 응답 속도를 제공하지만, 마이크로초까지 단축하기 위해서는 그 앞에 인메모리 캐시가 필요했습니다. **`DAX(DynamoDB Accelerator)`**는 바로 DynamoDB를 위해 특별히 설계된 인메모리 캐시로, 응답 시간을 마이크로초 수준까지 끌어내려 주는 역할을 합니다.

* **핵심 개념:** AWS 데이터 서비스의 지연 시간 계층 (Latency Hierarchy)

| 응답 시간 | **대표 서비스** | **주요 사용 사례** |
| :--- | :--- | :--- |
| **마이크로초 (μs)** | **ElastiCache, DAX** | 실시간 캐싱, 리더보드, 실시간 입찰 |
| **한 자릿수 밀리초 (ms)** | **DynamoDB** | 대규모 NoSQL 워크로드, 모바일/웹 앱 백엔드 |
| **수십 밀리초 (ms)** | **RDS, Aurora** | 관계형 데이터베이스, 일반적인 웹 애플리케이션 |
| **수 초 ~ 수 분** | **Redshift, Athena** | 데이터 분석(OLAP), 데이터 웨어하우징, 대화형 쿼리 |

---

## ## 문제 32: 탄력성 - 작업량에 맞춰 자동으로 일꾼 늘리기

> **시나리오:**
> 한 미디어 회사는 사용자가 업로드한 동영상을 처리하는 백엔드 시스템을 운영하고 있습니다. 처리 요청은 Amazon SQS 대기열에 메시지로 추가되고, EC2 인스턴스 작업자 그룹이 이 대기열을 폴링하여 동영상을 처리합니다. 동영상 업로드 양은 예측이 불가능하여, 피크 시간에는 대기열에 수천 개의 메시지가 쌓여 처리가 지연되고, 비 피크 시간에는 작업자 인스턴스들이 유휴 상태로 남아 비용을 낭비하고 있습니다.
>
> **문제:** 이러한 요구사항을 가장 효율적으로 충족하는 자동 확장(Auto Scaling) 전략은 무엇입니까?
>
> **A.** **예약된 조정(Scheduled Scaling)** 정책을 사용하여, 예상되는 피크 시간대(예: 오후 6시-10시)에 인스턴스 수를 늘리고 그 외 시간에는 줄이도록 설정합니다.
>
> **B.** **단계 조정(Step Scaling)** 정책을 설정하고, 작업자 인스턴스들의 평균 CPU 사용률(CPUUtilization)을 모니터링하는 CloudWatch 경보를 생성합니다. CPU 사용률이 임계값을 초과하면 인스턴스를 추가합니다.
>
> **C.** **대상 추적 조정(Target Tracking Scaling)** 정책을 생성합니다. 정책의 지표로 SQS 대기열의 `ApproximateNumberOfMessagesVisible`(대기 중인 메시지 수)을 선택하고, 인스턴스당 처리할 평균 메시지 수를 목표값으로 설정합니다.
>
> **D.** 동영상 처리 로직을 **AWS Lambda** 함수로 마이그레이션하고, S3에 동영상이 업로드될 때마다 Lambda 함수가 직접 트리거되도록 구성합니다.

---

### ### 풀이 및 정리

✅ **정답: C**

* **정답 분석:** 이 문제의 핵심은 '어떤 지표를 기준으로 확장할 것인가?'였습니다. CPU 사용률(B)은 이미 인스턴스들이 바빠진 후에야 높아지는 '후행 지표'인 반면, SQS 대기열에 쌓인 메시지 수(C)는 앞으로 처리해야 할 작업량을 직접적으로 보여주는 '선행 지표'입니다. **`대상 추적 조정`** 정책을 사용해 "인스턴스당 평균 N개의 메시지를 유지"하도록 설정하면, 대기열이 길어지는 순간 선제적으로 인스턴스를 늘려 처리 지연을 최소화할 수 있습니다.

* **핵심 개념:** Auto Scaling 정책 유형 비교

| 정책 유형 | **확장 기준** | **적합한 워크로드** | **특징** |
| :--- | :--- | :--- | :--- |
| **예약된 조정** | **시간** | 예측 가능한 스케줄 (예: 출퇴근 시간) | 정해진 시간에만 동작 |
| **대상 추적 조정** | **특정 목표값** (예: SQS 메시지 10개/인스턴스) | 변동이 심하지만 목표 관리가 쉬운 워크로드 | **선제적(Proactive) 대응 가능**, 설정이 가장 간단함 (권장) |
| **단계/단순 조정** | **CloudWatch 경보** (예: CPU > 70%) | 다양한 상황에 적용 가능 | **후응적(Reactive)**, 세부 설정이 복잡할 수 있음 |